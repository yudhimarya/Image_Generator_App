{"ast":null,"code":"const fs = require('fs');\nconst path = require('path');\nconst os = require('os');\nconst crypto = require('crypto');\nconst packageJson = require('../package.json');\nconst version = packageJson.version;\n\n// Array of tips to display randomly\nconst TIPS = ['üîê encrypt with dotenvx: https://dotenvx.com', 'üîê prevent committing .env to code: https://dotenvx.com/precommit', 'üîê prevent building .env in docker: https://dotenvx.com/prebuild', 'üõ†Ô∏è  run anywhere with `dotenvx run -- yourcommand`', '‚öôÔ∏è  specify custom .env file path with { path: \\'/custom/path/.env\\' }', '‚öôÔ∏è  enable debug logging with { debug: true }', '‚öôÔ∏è  override existing env vars with { override: true }', '‚öôÔ∏è  suppress all logs with { quiet: true }', '‚öôÔ∏è  write to custom object with { processEnv: myObject }', '‚öôÔ∏è  load multiple .env files with { path: [\\'.env.local\\', \\'.env\\'] }'];\n\n// Get a random tip from the tips array\nfunction _getRandomTip() {\n  return TIPS[Math.floor(Math.random() * TIPS.length)];\n}\nfunction parseBoolean(value) {\n  if (typeof value === 'string') {\n    return !['false', '0', 'no', 'off', ''].includes(value.toLowerCase());\n  }\n  return Boolean(value);\n}\nfunction supportsAnsi() {\n  return process.stdout.isTTY; // && process.env.TERM !== 'dumb'\n}\nfunction dim(text) {\n  return supportsAnsi() ? `\\x1b[2m${text}\\x1b[0m` : text;\n}\nconst LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg;\n\n// Parse src into an Object\nfunction parse(src) {\n  const obj = {};\n\n  // Convert buffer to string\n  let lines = src.toString();\n\n  // Convert line breaks to same format\n  lines = lines.replace(/\\r\\n?/mg, '\\n');\n  let match;\n  while ((match = LINE.exec(lines)) != null) {\n    const key = match[1];\n\n    // Default undefined or null to empty string\n    let value = match[2] || '';\n\n    // Remove whitespace\n    value = value.trim();\n\n    // Check if double quoted\n    const maybeQuote = value[0];\n\n    // Remove surrounding quotes\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2');\n\n    // Expand newlines if double quoted\n    if (maybeQuote === '\"') {\n      value = value.replace(/\\\\n/g, '\\n');\n      value = value.replace(/\\\\r/g, '\\r');\n    }\n\n    // Add to object\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _parseVault(options) {\n  options = options || {};\n  const vaultPath = _vaultPath(options);\n  options.path = vaultPath; // parse .env.vault\n  const result = DotenvModule.configDotenv(options);\n  if (!result.parsed) {\n    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);\n    err.code = 'MISSING_DATA';\n    throw err;\n  }\n\n  // handle scenario for comma separated keys - for use with key rotation\n  // example: DOTENV_KEY=\"dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod\"\n  const keys = _dotenvKey(options).split(',');\n  const length = keys.length;\n  let decrypted;\n  for (let i = 0; i < length; i++) {\n    try {\n      // Get full key\n      const key = keys[i].trim();\n\n      // Get instructions for decrypt\n      const attrs = _instructions(result, key);\n\n      // Decrypt\n      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);\n      break;\n    } catch (error) {\n      // last key\n      if (i + 1 >= length) {\n        throw error;\n      }\n      // try next key\n    }\n  }\n\n  // Parse decrypted .env string\n  return DotenvModule.parse(decrypted);\n}\nfunction _warn(message) {\n  console.error(`[dotenv@${version}][WARN] ${message}`);\n}\nfunction _debug(message) {\n  console.log(`[dotenv@${version}][DEBUG] ${message}`);\n}\nfunction _log(message) {\n  console.log(`[dotenv@${version}] ${message}`);\n}\nfunction _dotenvKey(options) {\n  // prioritize developer directly setting options.DOTENV_KEY\n  if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {\n    return options.DOTENV_KEY;\n  }\n\n  // secondary infra already contains a DOTENV_KEY environment variable\n  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {\n    return process.env.DOTENV_KEY;\n  }\n\n  // fallback to empty string\n  return '';\n}\nfunction _instructions(result, dotenvKey) {\n  // Parse DOTENV_KEY. Format is a URI\n  let uri;\n  try {\n    uri = new URL(dotenvKey);\n  } catch (error) {\n    if (error.code === 'ERR_INVALID_URL') {\n      const err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development');\n      err.code = 'INVALID_DOTENV_KEY';\n      throw err;\n    }\n    throw error;\n  }\n\n  // Get decrypt key\n  const key = uri.password;\n  if (!key) {\n    const err = new Error('INVALID_DOTENV_KEY: Missing key part');\n    err.code = 'INVALID_DOTENV_KEY';\n    throw err;\n  }\n\n  // Get environment\n  const environment = uri.searchParams.get('environment');\n  if (!environment) {\n    const err = new Error('INVALID_DOTENV_KEY: Missing environment part');\n    err.code = 'INVALID_DOTENV_KEY';\n    throw err;\n  }\n\n  // Get ciphertext payload\n  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;\n  const ciphertext = result.parsed[environmentKey]; // DOTENV_VAULT_PRODUCTION\n  if (!ciphertext) {\n    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);\n    err.code = 'NOT_FOUND_DOTENV_ENVIRONMENT';\n    throw err;\n  }\n  return {\n    ciphertext,\n    key\n  };\n}\nfunction _vaultPath(options) {\n  let possibleVaultPath = null;\n  if (options && options.path && options.path.length > 0) {\n    if (Array.isArray(options.path)) {\n      for (const filepath of options.path) {\n        if (fs.existsSync(filepath)) {\n          possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`;\n        }\n      }\n    } else {\n      possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`;\n    }\n  } else {\n    possibleVaultPath = path.resolve(process.cwd(), '.env.vault');\n  }\n  if (fs.existsSync(possibleVaultPath)) {\n    return possibleVaultPath;\n  }\n  return null;\n}\nfunction _resolveHome(envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath;\n}\nfunction _configVault(options) {\n  const debug = parseBoolean(process.env.DOTENV_CONFIG_DEBUG || options && options.debug);\n  const quiet = parseBoolean(process.env.DOTENV_CONFIG_QUIET || options && options.quiet);\n  if (debug || !quiet) {\n    _log('Loading env from encrypted .env.vault');\n  }\n  const parsed = DotenvModule._parseVault(options);\n  let processEnv = process.env;\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv;\n  }\n  DotenvModule.populate(processEnv, parsed, options);\n  return {\n    parsed\n  };\n}\nfunction configDotenv(options) {\n  const dotenvPath = path.resolve(process.cwd(), '.env');\n  let encoding = 'utf8';\n  let processEnv = process.env;\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv;\n  }\n  let debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || options && options.debug);\n  let quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || options && options.quiet);\n  if (options && options.encoding) {\n    encoding = options.encoding;\n  } else {\n    if (debug) {\n      _debug('No encoding is specified. UTF-8 is used by default');\n    }\n  }\n  let optionPaths = [dotenvPath]; // default, look for .env\n  if (options && options.path) {\n    if (!Array.isArray(options.path)) {\n      optionPaths = [_resolveHome(options.path)];\n    } else {\n      optionPaths = []; // reset default\n      for (const filepath of options.path) {\n        optionPaths.push(_resolveHome(filepath));\n      }\n    }\n  }\n\n  // Build the parsed data in a temporary object (because we need to return it).  Once we have the final\n  // parsed data, we will combine it with process.env (or options.processEnv if provided).\n  let lastError;\n  const parsedAll = {};\n  for (const path of optionPaths) {\n    try {\n      // Specifying an encoding returns a string instead of a buffer\n      const parsed = DotenvModule.parse(fs.readFileSync(path, {\n        encoding\n      }));\n      DotenvModule.populate(parsedAll, parsed, options);\n    } catch (e) {\n      if (debug) {\n        _debug(`Failed to load ${path} ${e.message}`);\n      }\n      lastError = e;\n    }\n  }\n  const populated = DotenvModule.populate(processEnv, parsedAll, options);\n\n  // handle user settings DOTENV_CONFIG_ options inside .env file(s)\n  debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || debug);\n  quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || quiet);\n  if (debug || !quiet) {\n    const keysCount = Object.keys(populated).length;\n    const shortPaths = [];\n    for (const filePath of optionPaths) {\n      try {\n        const relative = path.relative(process.cwd(), filePath);\n        shortPaths.push(relative);\n      } catch (e) {\n        if (debug) {\n          _debug(`Failed to load ${filePath} ${e.message}`);\n        }\n        lastError = e;\n      }\n    }\n    _log(`injecting env (${keysCount}) from ${shortPaths.join(',')} ${dim(`(tip: ${_getRandomTip()})`)}`);\n  }\n  if (lastError) {\n    return {\n      parsed: parsedAll,\n      error: lastError\n    };\n  } else {\n    return {\n      parsed: parsedAll\n    };\n  }\n}\n\n// Populates process.env from .env file\nfunction config(options) {\n  // fallback to original dotenv if DOTENV_KEY is not set\n  if (_dotenvKey(options).length === 0) {\n    return DotenvModule.configDotenv(options);\n  }\n  const vaultPath = _vaultPath(options);\n\n  // dotenvKey exists but .env.vault file does not exist\n  if (!vaultPath) {\n    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);\n    return DotenvModule.configDotenv(options);\n  }\n  return DotenvModule._configVault(options);\n}\nfunction decrypt(encrypted, keyStr) {\n  const key = Buffer.from(keyStr.slice(-64), 'hex');\n  let ciphertext = Buffer.from(encrypted, 'base64');\n  const nonce = ciphertext.subarray(0, 12);\n  const authTag = ciphertext.subarray(-16);\n  ciphertext = ciphertext.subarray(12, -16);\n  try {\n    const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce);\n    aesgcm.setAuthTag(authTag);\n    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;\n  } catch (error) {\n    const isRange = error instanceof RangeError;\n    const invalidKeyLength = error.message === 'Invalid key length';\n    const decryptionFailed = error.message === 'Unsupported state or unable to authenticate data';\n    if (isRange || invalidKeyLength) {\n      const err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)');\n      err.code = 'INVALID_DOTENV_KEY';\n      throw err;\n    } else if (decryptionFailed) {\n      const err = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY');\n      err.code = 'DECRYPTION_FAILED';\n      throw err;\n    } else {\n      throw error;\n    }\n  }\n}\n\n// Populate process.env with parsed values\nfunction populate(processEnv, parsed, options = {}) {\n  const debug = Boolean(options && options.debug);\n  const override = Boolean(options && options.override);\n  const populated = {};\n  if (typeof parsed !== 'object') {\n    const err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate');\n    err.code = 'OBJECT_REQUIRED';\n    throw err;\n  }\n\n  // Set process.env\n  for (const key of Object.keys(parsed)) {\n    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {\n      if (override === true) {\n        processEnv[key] = parsed[key];\n        populated[key] = parsed[key];\n      }\n      if (debug) {\n        if (override === true) {\n          _debug(`\"${key}\" is already defined and WAS overwritten`);\n        } else {\n          _debug(`\"${key}\" is already defined and was NOT overwritten`);\n        }\n      }\n    } else {\n      processEnv[key] = parsed[key];\n      populated[key] = parsed[key];\n    }\n  }\n  return populated;\n}\nconst DotenvModule = {\n  configDotenv,\n  _configVault,\n  _parseVault,\n  config,\n  decrypt,\n  parse,\n  populate\n};\nmodule.exports.configDotenv = DotenvModule.configDotenv;\nmodule.exports._configVault = DotenvModule._configVault;\nmodule.exports._parseVault = DotenvModule._parseVault;\nmodule.exports.config = DotenvModule.config;\nmodule.exports.decrypt = DotenvModule.decrypt;\nmodule.exports.parse = DotenvModule.parse;\nmodule.exports.populate = DotenvModule.populate;\nmodule.exports = DotenvModule;","map":{"version":3,"names":["fs","require","path","os","crypto","packageJson","version","TIPS","_getRandomTip","Math","floor","random","length","parseBoolean","value","includes","toLowerCase","Boolean","supportsAnsi","process","stdout","isTTY","dim","text","LINE","parse","src","obj","lines","toString","replace","match","exec","key","trim","maybeQuote","_parseVault","options","vaultPath","_vaultPath","result","DotenvModule","configDotenv","parsed","err","Error","code","keys","_dotenvKey","split","decrypted","i","attrs","_instructions","decrypt","ciphertext","error","_warn","message","console","_debug","log","_log","DOTENV_KEY","env","dotenvKey","uri","URL","password","environment","searchParams","get","environmentKey","toUpperCase","possibleVaultPath","Array","isArray","filepath","existsSync","endsWith","resolve","cwd","_resolveHome","envPath","join","homedir","slice","_configVault","debug","DOTENV_CONFIG_DEBUG","quiet","DOTENV_CONFIG_QUIET","processEnv","populate","dotenvPath","encoding","optionPaths","push","lastError","parsedAll","readFileSync","e","populated","keysCount","Object","shortPaths","filePath","relative","config","encrypted","keyStr","Buffer","from","nonce","subarray","authTag","aesgcm","createDecipheriv","setAuthTag","update","final","isRange","RangeError","invalidKeyLength","decryptionFailed","override","prototype","hasOwnProperty","call","module","exports"],"sources":["C:/Users/yudhi/Desktop/PROGRAMMING/PROJECT/IMAGE_GENERATOR/client/node_modules/dotenv/lib/main.js"],"sourcesContent":["const fs = require('fs')\nconst path = require('path')\nconst os = require('os')\nconst crypto = require('crypto')\nconst packageJson = require('../package.json')\n\nconst version = packageJson.version\n\n// Array of tips to display randomly\nconst TIPS = [\n  'üîê encrypt with dotenvx: https://dotenvx.com',\n  'üîê prevent committing .env to code: https://dotenvx.com/precommit',\n  'üîê prevent building .env in docker: https://dotenvx.com/prebuild',\n  'üõ†Ô∏è  run anywhere with `dotenvx run -- yourcommand`',\n  '‚öôÔ∏è  specify custom .env file path with { path: \\'/custom/path/.env\\' }',\n  '‚öôÔ∏è  enable debug logging with { debug: true }',\n  '‚öôÔ∏è  override existing env vars with { override: true }',\n  '‚öôÔ∏è  suppress all logs with { quiet: true }',\n  '‚öôÔ∏è  write to custom object with { processEnv: myObject }',\n  '‚öôÔ∏è  load multiple .env files with { path: [\\'.env.local\\', \\'.env\\'] }'\n]\n\n// Get a random tip from the tips array\nfunction _getRandomTip () {\n  return TIPS[Math.floor(Math.random() * TIPS.length)]\n}\n\nfunction parseBoolean (value) {\n  if (typeof value === 'string') {\n    return !['false', '0', 'no', 'off', ''].includes(value.toLowerCase())\n  }\n  return Boolean(value)\n}\n\nfunction supportsAnsi () {\n  return process.stdout.isTTY // && process.env.TERM !== 'dumb'\n}\n\nfunction dim (text) {\n  return supportsAnsi() ? `\\x1b[2m${text}\\x1b[0m` : text\n}\n\nconst LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg\n\n// Parse src into an Object\nfunction parse (src) {\n  const obj = {}\n\n  // Convert buffer to string\n  let lines = src.toString()\n\n  // Convert line breaks to same format\n  lines = lines.replace(/\\r\\n?/mg, '\\n')\n\n  let match\n  while ((match = LINE.exec(lines)) != null) {\n    const key = match[1]\n\n    // Default undefined or null to empty string\n    let value = (match[2] || '')\n\n    // Remove whitespace\n    value = value.trim()\n\n    // Check if double quoted\n    const maybeQuote = value[0]\n\n    // Remove surrounding quotes\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2')\n\n    // Expand newlines if double quoted\n    if (maybeQuote === '\"') {\n      value = value.replace(/\\\\n/g, '\\n')\n      value = value.replace(/\\\\r/g, '\\r')\n    }\n\n    // Add to object\n    obj[key] = value\n  }\n\n  return obj\n}\n\nfunction _parseVault (options) {\n  options = options || {}\n\n  const vaultPath = _vaultPath(options)\n  options.path = vaultPath // parse .env.vault\n  const result = DotenvModule.configDotenv(options)\n  if (!result.parsed) {\n    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`)\n    err.code = 'MISSING_DATA'\n    throw err\n  }\n\n  // handle scenario for comma separated keys - for use with key rotation\n  // example: DOTENV_KEY=\"dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod\"\n  const keys = _dotenvKey(options).split(',')\n  const length = keys.length\n\n  let decrypted\n  for (let i = 0; i < length; i++) {\n    try {\n      // Get full key\n      const key = keys[i].trim()\n\n      // Get instructions for decrypt\n      const attrs = _instructions(result, key)\n\n      // Decrypt\n      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key)\n\n      break\n    } catch (error) {\n      // last key\n      if (i + 1 >= length) {\n        throw error\n      }\n      // try next key\n    }\n  }\n\n  // Parse decrypted .env string\n  return DotenvModule.parse(decrypted)\n}\n\nfunction _warn (message) {\n  console.error(`[dotenv@${version}][WARN] ${message}`)\n}\n\nfunction _debug (message) {\n  console.log(`[dotenv@${version}][DEBUG] ${message}`)\n}\n\nfunction _log (message) {\n  console.log(`[dotenv@${version}] ${message}`)\n}\n\nfunction _dotenvKey (options) {\n  // prioritize developer directly setting options.DOTENV_KEY\n  if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {\n    return options.DOTENV_KEY\n  }\n\n  // secondary infra already contains a DOTENV_KEY environment variable\n  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {\n    return process.env.DOTENV_KEY\n  }\n\n  // fallback to empty string\n  return ''\n}\n\nfunction _instructions (result, dotenvKey) {\n  // Parse DOTENV_KEY. Format is a URI\n  let uri\n  try {\n    uri = new URL(dotenvKey)\n  } catch (error) {\n    if (error.code === 'ERR_INVALID_URL') {\n      const err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development')\n      err.code = 'INVALID_DOTENV_KEY'\n      throw err\n    }\n\n    throw error\n  }\n\n  // Get decrypt key\n  const key = uri.password\n  if (!key) {\n    const err = new Error('INVALID_DOTENV_KEY: Missing key part')\n    err.code = 'INVALID_DOTENV_KEY'\n    throw err\n  }\n\n  // Get environment\n  const environment = uri.searchParams.get('environment')\n  if (!environment) {\n    const err = new Error('INVALID_DOTENV_KEY: Missing environment part')\n    err.code = 'INVALID_DOTENV_KEY'\n    throw err\n  }\n\n  // Get ciphertext payload\n  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`\n  const ciphertext = result.parsed[environmentKey] // DOTENV_VAULT_PRODUCTION\n  if (!ciphertext) {\n    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`)\n    err.code = 'NOT_FOUND_DOTENV_ENVIRONMENT'\n    throw err\n  }\n\n  return { ciphertext, key }\n}\n\nfunction _vaultPath (options) {\n  let possibleVaultPath = null\n\n  if (options && options.path && options.path.length > 0) {\n    if (Array.isArray(options.path)) {\n      for (const filepath of options.path) {\n        if (fs.existsSync(filepath)) {\n          possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`\n        }\n      }\n    } else {\n      possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`\n    }\n  } else {\n    possibleVaultPath = path.resolve(process.cwd(), '.env.vault')\n  }\n\n  if (fs.existsSync(possibleVaultPath)) {\n    return possibleVaultPath\n  }\n\n  return null\n}\n\nfunction _resolveHome (envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath\n}\n\nfunction _configVault (options) {\n  const debug = parseBoolean(process.env.DOTENV_CONFIG_DEBUG || (options && options.debug))\n  const quiet = parseBoolean(process.env.DOTENV_CONFIG_QUIET || (options && options.quiet))\n\n  if (debug || !quiet) {\n    _log('Loading env from encrypted .env.vault')\n  }\n\n  const parsed = DotenvModule._parseVault(options)\n\n  let processEnv = process.env\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv\n  }\n\n  DotenvModule.populate(processEnv, parsed, options)\n\n  return { parsed }\n}\n\nfunction configDotenv (options) {\n  const dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding = 'utf8'\n  let processEnv = process.env\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv\n  }\n  let debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || (options && options.debug))\n  let quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || (options && options.quiet))\n\n  if (options && options.encoding) {\n    encoding = options.encoding\n  } else {\n    if (debug) {\n      _debug('No encoding is specified. UTF-8 is used by default')\n    }\n  }\n\n  let optionPaths = [dotenvPath] // default, look for .env\n  if (options && options.path) {\n    if (!Array.isArray(options.path)) {\n      optionPaths = [_resolveHome(options.path)]\n    } else {\n      optionPaths = [] // reset default\n      for (const filepath of options.path) {\n        optionPaths.push(_resolveHome(filepath))\n      }\n    }\n  }\n\n  // Build the parsed data in a temporary object (because we need to return it).  Once we have the final\n  // parsed data, we will combine it with process.env (or options.processEnv if provided).\n  let lastError\n  const parsedAll = {}\n  for (const path of optionPaths) {\n    try {\n      // Specifying an encoding returns a string instead of a buffer\n      const parsed = DotenvModule.parse(fs.readFileSync(path, { encoding }))\n\n      DotenvModule.populate(parsedAll, parsed, options)\n    } catch (e) {\n      if (debug) {\n        _debug(`Failed to load ${path} ${e.message}`)\n      }\n      lastError = e\n    }\n  }\n\n  const populated = DotenvModule.populate(processEnv, parsedAll, options)\n\n  // handle user settings DOTENV_CONFIG_ options inside .env file(s)\n  debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || debug)\n  quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || quiet)\n\n  if (debug || !quiet) {\n    const keysCount = Object.keys(populated).length\n    const shortPaths = []\n    for (const filePath of optionPaths) {\n      try {\n        const relative = path.relative(process.cwd(), filePath)\n        shortPaths.push(relative)\n      } catch (e) {\n        if (debug) {\n          _debug(`Failed to load ${filePath} ${e.message}`)\n        }\n        lastError = e\n      }\n    }\n\n    _log(`injecting env (${keysCount}) from ${shortPaths.join(',')} ${dim(`(tip: ${_getRandomTip()})`)}`)\n  }\n\n  if (lastError) {\n    return { parsed: parsedAll, error: lastError }\n  } else {\n    return { parsed: parsedAll }\n  }\n}\n\n// Populates process.env from .env file\nfunction config (options) {\n  // fallback to original dotenv if DOTENV_KEY is not set\n  if (_dotenvKey(options).length === 0) {\n    return DotenvModule.configDotenv(options)\n  }\n\n  const vaultPath = _vaultPath(options)\n\n  // dotenvKey exists but .env.vault file does not exist\n  if (!vaultPath) {\n    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`)\n\n    return DotenvModule.configDotenv(options)\n  }\n\n  return DotenvModule._configVault(options)\n}\n\nfunction decrypt (encrypted, keyStr) {\n  const key = Buffer.from(keyStr.slice(-64), 'hex')\n  let ciphertext = Buffer.from(encrypted, 'base64')\n\n  const nonce = ciphertext.subarray(0, 12)\n  const authTag = ciphertext.subarray(-16)\n  ciphertext = ciphertext.subarray(12, -16)\n\n  try {\n    const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce)\n    aesgcm.setAuthTag(authTag)\n    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`\n  } catch (error) {\n    const isRange = error instanceof RangeError\n    const invalidKeyLength = error.message === 'Invalid key length'\n    const decryptionFailed = error.message === 'Unsupported state or unable to authenticate data'\n\n    if (isRange || invalidKeyLength) {\n      const err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)')\n      err.code = 'INVALID_DOTENV_KEY'\n      throw err\n    } else if (decryptionFailed) {\n      const err = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY')\n      err.code = 'DECRYPTION_FAILED'\n      throw err\n    } else {\n      throw error\n    }\n  }\n}\n\n// Populate process.env with parsed values\nfunction populate (processEnv, parsed, options = {}) {\n  const debug = Boolean(options && options.debug)\n  const override = Boolean(options && options.override)\n  const populated = {}\n\n  if (typeof parsed !== 'object') {\n    const err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate')\n    err.code = 'OBJECT_REQUIRED'\n    throw err\n  }\n\n  // Set process.env\n  for (const key of Object.keys(parsed)) {\n    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {\n      if (override === true) {\n        processEnv[key] = parsed[key]\n        populated[key] = parsed[key]\n      }\n\n      if (debug) {\n        if (override === true) {\n          _debug(`\"${key}\" is already defined and WAS overwritten`)\n        } else {\n          _debug(`\"${key}\" is already defined and was NOT overwritten`)\n        }\n      }\n    } else {\n      processEnv[key] = parsed[key]\n      populated[key] = parsed[key]\n    }\n  }\n\n  return populated\n}\n\nconst DotenvModule = {\n  configDotenv,\n  _configVault,\n  _parseVault,\n  config,\n  decrypt,\n  parse,\n  populate\n}\n\nmodule.exports.configDotenv = DotenvModule.configDotenv\nmodule.exports._configVault = DotenvModule._configVault\nmodule.exports._parseVault = DotenvModule._parseVault\nmodule.exports.config = DotenvModule.config\nmodule.exports.decrypt = DotenvModule.decrypt\nmodule.exports.parse = DotenvModule.parse\nmodule.exports.populate = DotenvModule.populate\n\nmodule.exports = DotenvModule\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}